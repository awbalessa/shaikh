// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: chunks.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

const lexicalSearch = `-- name: LexicalSearch :many
WITH ranked_chunks AS (
  SELECT
    id,
    paradedb.score(id)::float8 AS score,
    embedded_chunk,
    raw_chunk,
    source,
    surah,
    ayah
  FROM rag.chunks
  WHERE id @@@ paradedb.boolean(
    must => ARRAY[
      paradedb.boolean(
        should => ARRAY[
          paradedb.match('tokenized_chunk', $2::text),
          paradedb.match('tokenized_chunk_title', $2::text)
        ]
      )
    ]
    ||
    CASE
      WHEN cardinality($3::content_type[]) > 0 THEN
        ARRAY[
          paradedb.term_set(terms => (
            SELECT ARRAY_AGG(paradedb.term('content_type', ct))
            FROM UNNEST($3::content_type[]) AS ct
          ))
        ]
      ELSE ARRAY[]::paradedb.searchqueryinput[]
    END
    ||
    CASE
      WHEN cardinality($4::source[]) > 0 THEN
        ARRAY[
          paradedb.term_set(terms => (
            SELECT ARRAY_AGG(paradedb.term('source', s))
            FROM UNNEST($4::source[]) AS s
          ))
        ]
      ELSE ARRAY[]::paradedb.searchqueryinput[]
    END
    ||
    CASE
      WHEN cardinality($5::int[]) > 1 THEN
        ARRAY[
          paradedb.term_set(terms => (
            SELECT ARRAY_AGG(paradedb.term('surah', s))
            FROM UNNEST($5::int[]) AS s
          ))
        ]

        WHEN cardinality($5::int[]) = 1 AND
             cardinality($6::int[]) > 0 THEN
        ARRAY[
          paradedb.boolean(
            should => (
              SELECT ARRAY_AGG(
                paradedb.boolean(must => ARRAY[
                  paradedb.term('surah', s),
                  paradedb.term('ayah', a)
                ])
              )
              FROM UNNEST($6::int[]) AS a,
                   (SELECT UNNEST($5::int[]) LIMIT 1) AS t(s)
            )
          )
        ]

      ELSE ARRAY[]::paradedb.searchqueryinput[]
    END
  )
),
deduped_chunks AS (
  SELECT DISTINCT ON (raw_chunk)
    id,
    score,
    embedded_chunk,
    source,
    surah,
    ayah
  FROM ranked_chunks
  ORDER BY raw_chunk, score DESC
)
SELECT id, score, embedded_chunk, source, surah, ayah FROM deduped_chunks
ORDER BY score DESC
LIMIT $1
`

type LexicalSearchParams struct {
	NumberOfChunks int32
	Query          string
	ContentTypes   []ContentType
	Sources        []Source
	Surahs         []int32
	Ayahs          []int32
}

type LexicalSearchRow struct {
	ID            int64
	Score         float64
	EmbeddedChunk string
	Source        Source
	Surah         pgtype.Int4
	Ayah          pgtype.Int4
}

func (q *Queries) LexicalSearch(ctx context.Context, arg LexicalSearchParams) ([]LexicalSearchRow, error) {
	rows, err := q.db.Query(ctx, lexicalSearch,
		arg.NumberOfChunks,
		arg.Query,
		arg.ContentTypes,
		arg.Sources,
		arg.Surahs,
		arg.Ayahs,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LexicalSearchRow
	for rows.Next() {
		var i LexicalSearchRow
		if err := rows.Scan(
			&i.ID,
			&i.Score,
			&i.EmbeddedChunk,
			&i.Source,
			&i.Surah,
			&i.Ayah,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const semanticSearch = `-- name: SemanticSearch :many
WITH ranked_chunks AS (
  SELECT
    id,
    (1 - (embedding <=> $2::vector))::float8 AS score,
    embedded_chunk,
    raw_chunk,
    source,
    surah,
    ayah
  FROM rag.chunks
  WHERE
    (
      cardinality($3::smallint[]) = 0
      OR labels && $3::smallint[]
    )
    AND
    (
      cardinality($4::smallint[]) = 0
      OR labels && $4::smallint[]
    )
    AND (
      (
        cardinality($5::smallint[]) = 0
        AND cardinality($6::smallint[]) = 0
      )
      OR (
        cardinality($5::smallint[]) > 1
        AND labels && $5::smallint[]
      )
      OR (
        cardinality($5::smallint[]) = 1
        AND cardinality($6::smallint[]) > 0
        AND labels && $5::smallint[]
        AND labels && $6::smallint[]
      )
      OR (
        cardinality($5::smallint[]) = 1
        AND cardinality($6::smallint[]) = 0
        AND labels && $5::smallint[]
      )
    )
),
deduped_chunks AS (
  SELECT DISTINCT ON (raw_chunk)
    id,
    score,
    embedded_chunk,
    source,
    surah,
    ayah
  FROM ranked_chunks
  ORDER BY raw_chunk, score DESC
)
SELECT id, score, embedded_chunk, source, surah, ayah FROM deduped_chunks
ORDER BY score DESC
LIMIT $1
`

type SemanticSearchParams struct {
	NumberOfChunks    int32
	Vector            pgvector.Vector
	ContentTypeLabels []int16
	SourceLabels      []int16
	SurahLabels       []int16
	AyahLabels        []int16
}

type SemanticSearchRow struct {
	ID            int64
	Score         float64
	EmbeddedChunk string
	Source        Source
	Surah         pgtype.Int4
	Ayah          pgtype.Int4
}

func (q *Queries) SemanticSearch(ctx context.Context, arg SemanticSearchParams) ([]SemanticSearchRow, error) {
	rows, err := q.db.Query(ctx, semanticSearch,
		arg.NumberOfChunks,
		arg.Vector,
		arg.ContentTypeLabels,
		arg.SourceLabels,
		arg.SurahLabels,
		arg.AyahLabels,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SemanticSearchRow
	for rows.Next() {
		var i SemanticSearchRow
		if err := rows.Scan(
			&i.ID,
			&i.Score,
			&i.EmbeddedChunk,
			&i.Source,
			&i.Surah,
			&i.Ayah,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
