// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: chunks.sql

package db

import (
	"context"

	pgvector_go "github.com/pgvector/pgvector-go"
)

const lexicalSearch = `-- name: LexicalSearch :many
WITH ranked_chunks AS (
  SELECT
    id,
    paradedb.score(id)::float8 AS score,
    embedded_chunk,
    raw_chunk,
    source,
    surah,
    ayah,
    parent_id
  FROM rag.chunks
  WHERE id @@@ paradedb.boolean(
    must => ARRAY[
      paradedb.boolean(
        should => ARRAY[
          paradedb.match('tokenized_chunk',        $2::text),
          paradedb.match('tokenized_chunk_title',  $2::text)
        ]
      )
    ]
    -- OPTIONAL: content_types
    || CASE
         WHEN cardinality(COALESCE($3::rag.content_type[], '{}')) >= 1 THEN
           ARRAY[
             paradedb.term_set(terms => (
               SELECT ARRAY_AGG(paradedb.term('content_type', ct))
               FROM UNNEST(COALESCE($3::rag.content_type[], '{}')) AS ct
             ))
           ]
         ELSE ARRAY[]::paradedb.searchqueryinput[]
       END
    -- OPTIONAL: sources
    || CASE
         WHEN cardinality(COALESCE($4::rag.source[], '{}')) >= 1 THEN
           ARRAY[
             paradedb.term_set(terms => (
               SELECT ARRAY_AGG(paradedb.term('source', s))
               FROM UNNEST(COALESCE($4::rag.source[], '{}')) AS s
             ))
           ]
         ELSE ARRAY[]::paradedb.searchqueryinput[]
       END
    -- OPTIONAL: surahs / ayahs
    || CASE
         -- many surahs
         WHEN cardinality(COALESCE($5::rag.surah[], '{}')) >= 2 THEN
           ARRAY[
             paradedb.term_set(terms => (
               SELECT ARRAY_AGG(paradedb.term('surah', s))
               FROM UNNEST(COALESCE($5::rag.surah[], '{}')) AS s
             ))
           ]
         -- single surah + specific ayahs
         WHEN cardinality(COALESCE($5::rag.surah[], '{}')) = 1
          AND cardinality(COALESCE($6::rag.ayah[],   '{}')) >= 1 THEN
           ARRAY[
             paradedb.boolean(
               should => (
                 SELECT ARRAY_AGG(
                   paradedb.boolean(must => ARRAY[
                     paradedb.term('surah', s),
                     paradedb.term('ayah',  a)
                   ])
                 )
                 FROM UNNEST(COALESCE($6::rag.ayah[], '{}')) AS a,
                      (SELECT UNNEST($5::rag.surah[]) LIMIT 1) AS t(s)
               )
             )
           ]
         ELSE ARRAY[]::paradedb.searchqueryinput[]
       END
  )
),
deduped_chunks AS (
  SELECT DISTINCT ON (raw_chunk)
    id,
    score,
    embedded_chunk,
    source,
    surah,
    ayah,
    parent_id
  FROM ranked_chunks
  ORDER BY raw_chunk, score DESC, id  -- deterministic tiebreaker
)
SELECT id, score, embedded_chunk, source, surah, ayah, parent_id
FROM deduped_chunks
ORDER BY score DESC, id
LIMIT $1
`

type LexicalSearchParams struct {
	NumberOfChunks int64            `db:"number_of_chunks"`
	Query          string           `db:"query"`
	ContentTypes   []RagContentType `db:"content_types"`
	Sources        []RagSource      `db:"sources"`
	Surahs         []RagSurah       `db:"surahs"`
	Ayahs          []RagAyah        `db:"ayahs"`
}

type LexicalSearchRow struct {
	ID            int64        `db:"id"`
	Score         float64      `db:"score"`
	EmbeddedChunk string       `db:"embedded_chunk"`
	Source        RagSource    `db:"source"`
	Surah         NullRagSurah `db:"surah"`
	Ayah          NullRagAyah  `db:"ayah"`
	ParentID      *int32       `db:"parent_id"`
}

func (q *Queries) LexicalSearch(ctx context.Context, arg LexicalSearchParams) ([]LexicalSearchRow, error) {
	rows, err := q.db.Query(ctx, lexicalSearch,
		arg.NumberOfChunks,
		arg.Query,
		arg.ContentTypes,
		arg.Sources,
		arg.Surahs,
		arg.Ayahs,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LexicalSearchRow{}
	for rows.Next() {
		var i LexicalSearchRow
		if err := rows.Scan(
			&i.ID,
			&i.Score,
			&i.EmbeddedChunk,
			&i.Source,
			&i.Surah,
			&i.Ayah,
			&i.ParentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const semanticSearch = `-- name: SemanticSearch :many
WITH ranked_chunks AS (
  SELECT
    id,
    (1 - (embedding <=> $2::public.vector))::float8 AS score,
    embedded_chunk,
    raw_chunk,
    source,
    surah,
    ayah,
    parent_id
  FROM rag.chunks
  WHERE
    (
      cardinality(COALESCE($3::smallint[], '{}')) = 0
      OR labels && COALESCE($3::smallint[], '{}')
    )
    AND
    (
      cardinality(COALESCE($4::smallint[], '{}')) = 0
      OR labels && COALESCE($4::smallint[], '{}')
    )
    AND (
      -- no surah nor ayah filter
      (
        cardinality(COALESCE($5::smallint[], '{}')) = 0
        AND cardinality(COALESCE($6::smallint[],  '{}')) = 0
      )
      -- multiple surahs
      OR (
        cardinality(COALESCE($5::smallint[], '{}')) >= 2
        AND labels && COALESCE($5::smallint[], '{}')
      )
      -- single surah + specific ayahs
      OR (
        cardinality(COALESCE($5::smallint[], '{}')) = 1
        AND cardinality(COALESCE($6::smallint[],  '{}')) >= 1
        AND labels && COALESCE($5::smallint[], '{}')
        AND labels && COALESCE($6::smallint[],  '{}')
      )
      -- single surah only
      OR (
        cardinality(COALESCE($5::smallint[], '{}')) = 1
        AND cardinality(COALESCE($6::smallint[],  '{}')) = 0
        AND labels && COALESCE($5::smallint[], '{}')
      )
    )
),
deduped_chunks AS (
  SELECT DISTINCT ON (raw_chunk)
    id,
    score,
    embedded_chunk,
    source,
    surah,
    ayah,
    parent_id
  FROM ranked_chunks
  ORDER BY raw_chunk, score DESC, id  -- deterministic tiebreaker
)
SELECT id, score, embedded_chunk, source, surah, ayah, parent_id
FROM deduped_chunks
ORDER BY score DESC, id
LIMIT $1
`

type SemanticSearchParams struct {
	NumberOfChunks    int64              `db:"number_of_chunks"`
	Vector            pgvector_go.Vector `db:"vector"`
	ContentTypeLabels []int16            `db:"content_type_labels"`
	SourceLabels      []int16            `db:"source_labels"`
	SurahLabels       []int16            `db:"surah_labels"`
	AyahLabels        []int16            `db:"ayah_labels"`
}

type SemanticSearchRow struct {
	ID            int64        `db:"id"`
	Score         float64      `db:"score"`
	EmbeddedChunk string       `db:"embedded_chunk"`
	Source        RagSource    `db:"source"`
	Surah         NullRagSurah `db:"surah"`
	Ayah          NullRagAyah  `db:"ayah"`
	ParentID      *int32       `db:"parent_id"`
}

func (q *Queries) SemanticSearch(ctx context.Context, arg SemanticSearchParams) ([]SemanticSearchRow, error) {
	rows, err := q.db.Query(ctx, semanticSearch,
		arg.NumberOfChunks,
		arg.Vector,
		arg.ContentTypeLabels,
		arg.SourceLabels,
		arg.SurahLabels,
		arg.AyahLabels,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SemanticSearchRow{}
	for rows.Next() {
		var i SemanticSearchRow
		if err := rows.Scan(
			&i.ID,
			&i.Score,
			&i.EmbeddedChunk,
			&i.Source,
			&i.Surah,
			&i.Ayah,
			&i.ParentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
