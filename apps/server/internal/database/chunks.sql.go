// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: chunks.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	pgvector_go "github.com/pgvector/pgvector-go"
)

const lexicalSearch = `-- name: LexicalSearch :many
SELECT
  id,
  paradedb.score(id)::float8 AS score,
  embedded_chunk,
  source,
  surah,
  ayah
FROM chunks
WHERE id @@@ paradedb.boolean(
  must => ARRAY[
    paradedb.boolean(
      should => ARRAY[
        paradedb.match('tokenized_chunk', $1::text),
        paradedb.match('tokenized_chunk_title', $1::text)
      ]
    )
  ]
  ||
  CASE
    WHEN $2::content_type IS NOT NULL
    THEN ARRAY[paradedb.term('content_type', $2::content_type)]
    ELSE ARRAY[]::paradedb.searchqueryinput[]
  END
  ||
  CASE
    WHEN $3::source IS NOT NULL
    THEN ARRAY[paradedb.term('source', $3::source)]
    ELSE ARRAY[]::paradedb.searchqueryinput[]
  END
  ||
  CASE
    WHEN $4::int IS NOT NULL
    THEN ARRAY[paradedb.term('surah', $4::int)]
    ELSE ARRAY[]::paradedb.searchqueryinput[]
  END
  ||
  CASE
    WHEN $4::int IS NOT NULL
     AND $5::int IS NOT NULL
     AND $6::int IS NOT NULL
    THEN ARRAY[paradedb.range('ayah', int4range($5, $6, '[]'))]
    ELSE ARRAY[]::paradedb.searchqueryinput[]
  END
)
ORDER BY score DESC
LIMIT $7
`

type LexicalSearchParams struct {
	Query          string
	ContentType    NullContentType
	Source         NullSource
	Surah          pgtype.Int4
	AyahStart      pgtype.Int4
	AyahEnd        pgtype.Int4
	NumberOfChunks int32
}

type LexicalSearchRow struct {
	ID            int64
	Score         float64
	EmbeddedChunk string
	Source        Source
	Surah         pgtype.Int4
	Ayah          pgtype.Int4
}

func (q *Queries) LexicalSearch(ctx context.Context, arg LexicalSearchParams) ([]LexicalSearchRow, error) {
	rows, err := q.db.Query(ctx, lexicalSearch,
		arg.Query,
		arg.ContentType,
		arg.Source,
		arg.Surah,
		arg.AyahStart,
		arg.AyahEnd,
		arg.NumberOfChunks,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LexicalSearchRow
	for rows.Next() {
		var i LexicalSearchRow
		if err := rows.Scan(
			&i.ID,
			&i.Score,
			&i.EmbeddedChunk,
			&i.Source,
			&i.Surah,
			&i.Ayah,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const semanticSearch = `-- name: SemanticSearch :many
SELECT
    id,
    (1 - embedding <=> $1::vector)::float8 as score,
    embedded_chunk,
    source,
    surah,
    ayah
FROM chunks
WHERE (
  cardinality($2::smallint[]) = 0
  OR labels && $2::smallint[]
)
ORDER BY score DESC
LIMIT $3
`

type SemanticSearchParams struct {
	Vector         pgvector_go.Vector
	LabelFilters   []int16
	NumberOfChunks int32
}

type SemanticSearchRow struct {
	ID            int64
	Score         float64
	EmbeddedChunk string
	Source        Source
	Surah         pgtype.Int4
	Ayah          pgtype.Int4
}

func (q *Queries) SemanticSearch(ctx context.Context, arg SemanticSearchParams) ([]SemanticSearchRow, error) {
	rows, err := q.db.Query(ctx, semanticSearch, arg.Vector, arg.LabelFilters, arg.NumberOfChunks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SemanticSearchRow
	for rows.Next() {
		var i SemanticSearchRow
		if err := rows.Scan(
			&i.ID,
			&i.Score,
			&i.EmbeddedChunk,
			&i.Source,
			&i.Surah,
			&i.Ayah,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
